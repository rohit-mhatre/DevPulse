import { app, BrowserWindow, ipcMain, shell } from 'electron';
import { createServer } from 'http';
import { LocalDatabase } from './database';
import { ActivityMonitor } from './activity-monitor';
import { SystemTrayController } from './tray';
import { ProjectDetector } from './project-detector';
import { AppConfig } from './config';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Global application components
let database: LocalDatabase;
let activityMonitor: ActivityMonitor;
let trayController: SystemTrayController;
let mainWindow: BrowserWindow | null = null;

const createWindow = (): BrowserWindow => {
  // Create the browser window.
  const window = new BrowserWindow({
    height: 800,
    width: 1200,
    title: 'DevPulse',
    show: false, // Don't show initially, let tray handle visibility
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  // Load the index.html of the app.
  window.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Only open DevTools in development
  if (process.env.NODE_ENV === 'development') {
    window.webContents.openDevTools();
  }

  // Handle window closed
  window.on('closed', () => {
    mainWindow = null;
  });

  // Handle external links - force them to open in external browser
  window.webContents.setWindowOpenHandler(({ url }) => {
    // If it's localhost:3000 (dashboard), open in external browser
    if (url.includes('localhost:3000')) {
      shell.openExternal(url);
      return { action: 'deny' }; // Prevent opening in Electron
    }
    return { action: 'allow' }; // Allow other URLs
  });

  // Also handle navigation attempts
  window.webContents.on('will-navigate', (event, navigationUrl) => {
    if (navigationUrl.includes('localhost:3000')) {
      event.preventDefault();
      shell.openExternal(navigationUrl);
    }
  });

  // Listen for distraction warnings from ActivityMonitor
  window.webContents.on('did-finish-load', () => {
    // Re-send any pending distraction warnings when window loads
    console.log('Main window loaded, ready for IPC messages');
  });

  // Handle minimize to tray
  window.on('minimize', () => {
    window.hide();
  });

  return window;
};

const createDataServer = (): void => {
  const server = createServer((req, res) => {
    // Add CORS headers
    res.setHeader('Access-Control-Allow-Origin', 'http://localhost:3000');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

    if (req.method === 'OPTIONS') {
      res.writeHead(200);
      res.end();
      return;
    }

    const url = new URL(req.url!, 'http://localhost');
    
    if (url.pathname === '/api/activity') {
      try {
        const dateParam = url.searchParams.get('date');
        const targetDate = dateParam ? new Date(dateParam) : new Date();
        const startOfDay = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
        const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);
        
        const activities = database.getActivitiesByTimeRange(startOfDay, endOfDay);
        const projects = database.getAllProjects();
        
        // Calculate stats
        const totalTime = activities.reduce((sum, a) => sum + a.duration_seconds, 0);
        const stats = {
          totalTime,
          activities: activities.length,
          activeProjects: new Set(activities.map(a => a.project_id).filter(Boolean)).size,
          avgSessionTime: activities.length > 0 ? Math.floor(totalTime / activities.length) : 0,
          topApp: activities.length > 0 
            ? activities.reduce((acc, curr) => acc.app_name === curr.app_name ? acc : curr, activities[0]).app_name
            : '',
          productivityScore: Math.min(Math.floor((totalTime / 28800) * 100), 100) // Out of 8 hours
        };

        const responseData = {
          activities: activities.map(a => ({
            timestamp: a.started_at.getTime(),
            activity_type: a.activity_type,
            app_name: a.app_name,
            duration_seconds: a.duration_seconds,
            project_name: projects.find(p => p.id === a.project_id)?.name || null,
            started_at: a.started_at.toISOString()
          })),
          projects: projects.map(p => ({
            id: p.id,
            name: p.name,
            path: p.path
          })),
          stats,
          metadata: {
            source: 'desktop-app',
            responseTime: 0,
            date: targetDate.toISOString().split('T')[0]
          }
        };

        res.setHeader('Content-Type', 'application/json');
        res.writeHead(200);
        res.end(JSON.stringify(responseData));
      } catch (error) {
        console.error('Data server error:', error);
        res.writeHead(500);
        res.end(JSON.stringify({ error: 'Internal server error' }));
      }
    } else {
      res.writeHead(404);
      res.end(JSON.stringify({ error: 'Not found' }));
    }
  });

  server.listen(3001, 'localhost', () => {
    console.log('ðŸ“¡ Data server running on http://localhost:3001');
  });
};

const setupIPCHandlers = (): void => {
  // Handle requests for real activity data
  ipcMain.handle('get-activity-stats', async () => {
    try {
      const today = new Date();
      const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);
      
      const activities = database.getActivitiesByTimeRange(startOfDay, endOfDay);
      const totalTime = activities.reduce((sum, a) => sum + a.duration_seconds, 0);
      
      // Group by activity type
      const byType = activities.reduce((acc, activity) => {
        acc[activity.activity_type] = (acc[activity.activity_type] || 0) + activity.duration_seconds;
        return acc;
      }, {} as Record<string, number>);

      return {
        totalTime,
        activities: activities.length,
        byType,
        hasData: activities.length > 0
      };
    } catch (error) {
      console.error('Error getting activity stats:', error);
      return { totalTime: 0, activities: 0, byType: {}, hasData: false };
    }
  });

  ipcMain.handle('get-tracking-status', () => {
    const isTracking = activityMonitor?.isCurrentlyMonitoring() || false;
    console.log(`ðŸ” IPC get-tracking-status called - isTracking: ${isTracking}`);
    return {
      isTracking,
      currentActivity: activityMonitor?.getCurrentActivity() || null,
      lastActivityTime: activityMonitor?.getLastActivityTime() || new Date()
    };
  });

  ipcMain.handle('get-todays-summary', async () => {
    try {
      const today = new Date();
      const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      const endOfDay = new Date(startOfDay.getTime() + 24 * 60 * 60 * 1000);
      
      const activities = database.getActivitiesByTimeRange(startOfDay, endOfDay);
      return activities;
    } catch (error) {
      console.error('Error getting today\'s summary:', error);
      return [];
    }
  });

  ipcMain.handle('get-dashboard-url', () => {
    const config = AppConfig.getInstance();
    return config.getDashboardUrl();
  });

  ipcMain.handle('open-external', (_, url: string) => {
    return shell.openExternal(url);
  });

  // Focus Mode IPC handlers
  ipcMain.handle('focus-start-session', async (_, sessionId: string) => {
    try {
      activityMonitor.enableFocusMode(sessionId);
      return { success: true, sessionId };
    } catch (error) {
      console.error('Error starting focus session:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('focus-end-session', async () => {
    try {
      const stats = activityMonitor.getFocusSessionStats();
      activityMonitor.disableFocusMode();
      return { success: true, stats };
    } catch (error) {
      console.error('Error ending focus session:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('focus-get-status', () => {
    try {
      return {
        isActive: activityMonitor.isFocusModeActive(),
        currentSession: activityMonitor.getCurrentFocusSession(),
        stats: activityMonitor.getFocusSessionStats()
      };
    } catch (error) {
      console.error('Error getting focus status:', error);
      return { isActive: false, currentSession: null, stats: { warnings: 0, duration: 0 } };
    }
  });
};

const initializeApplication = async (): Promise<void> => {
  try {
    console.log('Initializing DevPulse...');

    // Initialize database
    database = new LocalDatabase();
    console.log('Database initialized');

    // Initialize activity monitor
    activityMonitor = new ActivityMonitor(database);
    console.log('Activity monitor initialized');

    // Initialize system tray
    trayController = new SystemTrayController(activityMonitor, database);
    trayController.createTray();
    trayController.startPeriodicUpdates();
    console.log('System tray initialized');

    // Start activity monitoring automatically
    try {
      await activityMonitor.startMonitoring();
      trayController.updateStatus(true);
      console.log('Activity monitoring started automatically');
    } catch (error) {
      console.error('Could not start activity monitoring:', error);
      console.log('You may need to grant screen recording permissions');
    }

    // Create main window but don't show it initially
    mainWindow = createWindow();
    
    // Set up IPC handlers for real data communication
    setupIPCHandlers();
    
    // Start data server for web dashboard
    createDataServer();
    
    console.log('DevPulse initialization complete');
  } catch (error) {
    console.error('Error initializing application:', error);
    app.quit();
  }
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', initializeApplication);

// Handle application lifecycle events
app.on('window-all-closed', () => {
  // On macOS, don't quit when all windows are closed - keep running in system tray
  if (process.platform !== 'darwin') {
    // On other platforms, you might want different behavior
    console.log('All windows closed, continuing to run in system tray');
  }
});

app.on('before-quit', (event) => {
  // Cleanup before quitting
  if (activityMonitor) {
    activityMonitor.cleanup();
  }
  if (database) {
    database.cleanup();
  }
  if (trayController) {
    trayController.cleanup();
  }
  console.log('DevPulse cleanup completed');
});

app.on('activate', () => {
  // On OS X, show the main window when the app icon is clicked
  if (mainWindow) {
    mainWindow.show();
  } else if (BrowserWindow.getAllWindows().length === 0) {
    mainWindow = createWindow();
    mainWindow.show();
  }
});

// Handle second instance (prevent multiple instances)
app.on('second-instance', () => {
  // Someone tried to run a second instance, show our window instead
  if (mainWindow) {
    if (mainWindow.isMinimized()) mainWindow.restore();
    mainWindow.focus();
    mainWindow.show();
  }
});

// Prevent multiple instances
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
  app.quit();
}

// Handle app protocols and deep linking (for future use)
app.setAsDefaultProtocolClient('devpulse');

// Handle unhandled errors
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
});
